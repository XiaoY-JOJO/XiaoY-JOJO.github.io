---
layout: post
title:  "深入理解JVM（一）"
date:   2020-08-24 11:33:25
categories: JVM
tags: Java JVM 内存
---

* content
{:toc}

深入理解JVM读后总结。





## 深入理解JVM（一）

### 内存区域

`线程共享`的部分有方法区和堆，`线程私有`的部分有虚拟机栈、本地方法栈和程序计数器。

#### 程序计数器
程序计数器主要有两个作用：
- 字节码解释器通过改变程序计数器调整指令，实现循环、选择等流程控制；
- 多线程时，用于记录当前线程执行的位置

#### 虚拟机栈
- 虚拟机栈由栈帧组成，方法调用则会使一个对应栈帧入栈，调用结束则弹出。
- 虚拟机栈中最主要的内容时局部变量表，存放了数据类型和对象引用(reference，后面会详细讲到)等

#### 本地方法栈
为虚拟机执行Native方法服务，HotSpot中两个栈是一体的。

#### 堆
在虚拟机启动时创建，是JVM中最大的一块内存，只用于存放对象实例。可以细分为新生代和老年代，更细一点为eden区、s0区、s1区和tentired区。虽然堆是线程共享的，但是可以划分出线程私有的`TLAB`(分配缓冲区)。

#### 方法区
用于存储JVM加载过的类信息、运行时常量池、静态变量等

### 对象的创建

1. 执行类加载检查：首先检查new指令的参数能否在常量池中定位到一个类的符号引用，如果存在则检查该类是否已被加载、解析和初始化，若不存在则先执行相应的类加载过程。
2. 分配内存：分配方式有`指针碰撞`和`空闲列表`两种。使用哪一种取决于java堆内存是否规整，而是否规整又取决于选用的垃圾回收器是否带有整理过程，典型的`Serial`和`ParNew`是带整理的回收器，`CMS`是不带整理的回收器。
   - 空闲列表：JVM维护一个列表，记录可用的内存块，分配时选用足够大的内存块划分给对象实例；
   - 指针碰撞：用过的内存整合到一边，可用的内存整合到另一边，中间以一个分界值指针隔开，移动指针至对象相应的内存大小处。
3. 初始化零值：保证对象的实例字段在代码中不用赋初始值就可以直接使用。
4. 设置对象头：对对象头进行必要的设置，如对象的哈希码，对象属于哪个类，对象的GC分代年龄等都存放在对象头中。
5. 执行init方法：此时所有的字段都为0，执行init使对象按程序员的意愿初始化。

#### 内存分配存在的并发问题
对象在JVM中的创建不是原子性操作，并发时可能存在安全问题。例如正在给对象A分配内存，指针还未修改，对象B使用了同一指针来分配内存。有两种解决方式：
1. 采用CAS+失败重试的方式保证更新操作的原子性
2. 把内存分配的动作划分到不同的线程中进行：在每个线程的堆内存中分配一块本地线程分配缓冲（TLAB）

#### 对象的访问定位
java程序通过栈上的reference数据来操作堆上的对象，对象的主流访问方式有两种：`使用句柄`和`直接指针`。
1. 使用句柄：reference存储的是对象的句柄地址，句柄中包含了对象`实例数据`和`类型数据`各自的具体地址信息，实例数据在堆中，类型数据在方法区存放；
2. 使用直接指针：reference存储的是对象地址，此时对象则要考虑如何存放访问类型数据的相关信息。
3. 句柄的优势是稳定，对象被移动只会改变句柄的实例数据指针；直接指针的优势就是速度快，节省一次定位的开销。

#### 对象的内存布局
对象在内存中的布局分为三块区域：`对象头`、`实例数据`、`对齐填充`。

##### 对象头
1. 对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码，对象分代年龄，锁状态标志等，这部分称为`Mark Word`。比如对象处于未被锁定的状态下，32bit空间中，25bit存储哈希码，4bit存储分代年龄，2bit存储锁标志位，还有1bit固定为0。
2. 第二部分是类型指针：即指向该对象的类元数据的指针，通过该指针缺点对象是哪个类的实例。
3. 如果对象是一个java数组，那么对象头还必须有一块用于记录数组长度的数据。

##### 实例数据
实例数据是对象真正存储的有效信息，即定义的各种类型的字段内容。无论是从父类继承下来的还是子类中定义的，都需要记录。

##### 对齐填充
该部分仅起占位符的作用，不是必然存在的。



