## 知识点巩固复习
### AOP配置

- 切面实现了跨多个应用对象逻辑的模块化；
- AOP配置就是动态代理的典型应用；
- AOP配置共有三种方式，基于API，基于注解，基于XML配置文件；
- 基于API的配置方式需要定义拦截类实现相关接口，并实现相关拦截方法，在xml中配置拦截规则；
- 基于`@Aspect`注解，在对象类中添加要被拦截的方法，用`@Aspect`注解表明是切面类，用 `@Pointcut`注解表明切点（拦截规则），使用`@Before`、`@After`等注解定义通知（拦截方法），xml配置注解类；
- 基于XML标签，配置拦截处理类，`<aop:config>`、`<aop:pointcut>`标签配置拦截规则，`<aop:aspect`标签配置拦截方法；
- 调用`getBean()`返回的是代理类的示例。


### 建造者模式

- 包含四个角色：抽象建造者，具体建造者，产品角色，指挥者；
- 抽象建造者主要有两种方法：创建复杂对象的组件，返回复杂对象；
- 具体建造者实现或继承抽象建造者，包含各个部件的具体构造方法和对象返回；
- 指挥者负责安排建造次序，将具体建造者作为参数传入指挥者的构造函数。


### 克隆

- 深克隆和浅克隆的根本差别；
- `Arrays.copyOf()`的原理；
- 深克隆的三种实现方式，将父类和子类都实现克隆、字节流、JSON工具类；
- 实现克隆需要实现`Cloneable`接口，重写`clone()`；
- 利用字节流要求对象可以被序列化，否则会抛异常，`People p2 = (People) StreamClone.clone(p1)`;；
- 先调用`toJson()`、再调用`fromJson()`，`People p2 = gson.fromJson(gson.toJson(p1), People.class)`。

### 单例模式

- 饿汉式和懒汉式区别和优缺点；
- `DCL`中为什么要double check?为什么要用`volatile`修饰Singleton对象?
- 静态内部类和枚举方式线程安全的原理；

### 适配器模式

- 对象适配器和类适配器的区别；
- 角色有三个：目标抽象类，适配器类，适配者类三者的关系；
- 电压适配器

