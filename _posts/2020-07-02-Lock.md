---
layout: post
title:  "锁的了解"
date:   2020-07-03 16:19:05
categories: 线程安全
tags: 多线程 源码解析 锁 
---

* content
{:toc}

本文概括了当前java中部分锁的理解，包括乐观悲观锁，共享独占锁，可重入锁。





## 锁

### 乐观锁和悲观锁
- 悲观锁指的是数据对外界的修改采取保守策略，它认为线程很容易会把数据修改掉，因此在整个数据被修改的过程中都会采取锁定状态，直到一个线程使用完，其他线程才可以继续使用。
- 乐观锁认为一般情况下数据在修改时不会出现冲突，所以在数据访问之前不会加锁，只是在数据提交更改时，才会对数据进行检测。

#### ABA问题
- 乐观锁大部分都是通过 CAS（比较并交换）操作实现的，CAS 是一个多线程同步的原子指令，CAS 操作包含三个重要的信息，即内存位置、预期原值和新值。如果内存位置的值和预期的原值相等的话，那么就可以把该位置的值更新为新值，否则不做任何修改。
- CAS 可能会造成 ABA 的问题，当一个位置被读取两次，两次读取具有相同的值，并且“值相同”用于指示“什么都没有改变”。但是，另一个线程可以在两次读取之间执行并更改值，执行其他工作，然后将值改回，因此，即使第二个线程的工作违反了该假设，也使第一个线程认为“什么都没有改变”。
- JDK 在 1.5 时提供了 AtomicStampedReference 类也可以解决 ABA 的问题，此类维护了一个“版本号” Stamp，每次在比较时不止比较当前值还比较版本号，这样就解决了 ABA 的问题。

```
public class AtomicStampedReference<V> {
    private static class Pair<T> {
        final T reference;
        final int stamp; // “版本号”
        private Pair(T reference, int stamp) {
            this.reference = reference;
            this.stamp = stamp;
        }
        static <T> Pair<T> of(T reference, int stamp) {
            return new Pair<T>(reference, stamp);
        }
    }
    // 比较并设置
    public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp, // 原版本号
                                 int newStamp) { // 新版本号
        Pair<V> current = pair;
        return
            expectedReference == current.reference &&
            expectedStamp == current.stamp &&
            ((newReference == current.reference &&
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    }
    //.......省略其他源码
}

```
乐观锁有一个优点，它在提交的时候才进行锁定的，因此不会造成死锁.

### 可重入锁
```
public class LockExample {
    public static void main(String[] args) {
        reentrantA(); // 可重入锁
    }
    /**
     * 可重入锁 A 方法
     */
    private synchronized static void reentrantA() {
        System.out.println(Thread.currentThread().getName() + "：执行 reentrantA");
        reentrantB();
    }
    /**
     * 可重入锁 B 方法
     */
    private synchronized static void reentrantB() {
        System.out.println(Thread.currentThread().getName() + "：执行 reentrantB");
    }
}
main：执行 reentrantA
main：执行 reentrantB

```
ReentrantLock 和 synchronized 都是可重入锁,从结果可以看出 reentrantA 方法和 reentrantB 方法的执行线程都是“main” ，我们调用了 reentrantA 方法，它的方法中嵌套了 reentrantB，如果 synchronized 是不可重入的话，那么线程会被一直堵塞。可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程(getName())，并且锁的内部维护了一个计数器.

### 共享锁和独占锁
- 只能被单线程持有的锁叫独占锁，可以被多线程持有的锁叫共享锁
- 独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 synchronized 就是独占锁，而 ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。
